require('dotenv').config();

const { closeDBConnection, closeCustomConnectionPool } = require('../database')

const app = require('../app')
const http = require('http')
const server = http.createServer(app)

server.listen()

server.on('listening', onListening)

/**
 * Event listener for HTTP server "listening" event.
 */
function onListening() {
	let addr = server.address();
	let bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port
	console.error('LOG(Using error) -> Listening on ' + bind)
}


async function cleanup() {
	try {
		// 1. 关闭HTTP服务器（停止接收新连接，等待现有连接处理完毕）
		server.close(async (err) => {
			if (err) {
				console.error('关闭服务器失败:', err)
				process.exit(1) // 强制退出
			}
			console.error('LOG(Using error) -> HTTP服务器已关闭')

			// 2. 关闭数据库连接池
			await closeCustomConnectionPool()
			await closeDBConnection()

			// 3. 退出进程
			process.exit(0)
		});
	} catch (err) {
		console.error('LOG(Using error) -> 清理资源失败:', err)
		process.exit(1)
	}
}

// 监听终止信号：SIGINT（Ctrl+C）、SIGTERM（kill命令）
process.on('SIGINT', cleanup)
process.on('SIGTERM', cleanup)

// 处理未捕获的异常，避免进程挂起
process.on('uncaughtException', (err) => {
	console.error('LOG(Using error) -> 未捕获的异常:', err)
	cleanup().then(() => process.exit(1))
})

// 处理未捕获的Promise拒绝
process.on('unhandledRejection', (reason) => {
	console.error('LOG(Using error) -> 未处理的Promise拒绝:', reason)
	cleanup().then(() => process.exit(1))
})